% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/IplBoost.R
\name{IplBoost}
\alias{IplBoost}
\title{IplBoost}
\usage{
IplBoost(times, status, mat, lms, w, M, lambda, verbose = FALSE,
  standardise = TRUE, compute.ipl = TRUE)
}
\arguments{
\item{times}{A n-dimensional vector of survival times}

\item{status}{A n-dimensional vector of censoring indicators}

\item{mat}{A n x p matrix of covariate values}

\item{lms}{A S-dimensinal vector of landmark points to produce dynamic 
predictions from}

\item{w}{A number. The "landmark interval width" or how far ahead the 
survival predictions will be made}

\item{M}{A number. The number of boosting iterations to perform}

\item{lambda}{A number or an S-dimensional vector. The regularisation
parameter for the boosting algorithm.}

\item{verbose}{Boolean. Indicates whether the iteration number should
be printed to the console.}

\item{standardise}{Boolean. Indicates if covariates should be standardised prior to
fitting the model. Coefficient estimates are transformed back to the scale of the data if true.}

\item{compute.ipl}{Boolean. Indicated if the ipl should be computed for each step.}
}
\value{
A list of (M + 1) elements containing the landmark coefficients as a (S x p)
matrix for each iteration.

A vector of the ipl computed for each step.
}
\description{
This is the main function of the package, that fits sliding landmark models
by boosting van Houwelingens integrated partial likelihood, following the strategy
of \link[CoxBoost]{CoxBoost}.
}
\examples{
# Tune the number of iterations via cross validation (see \\link{cv.Iplboost})
cv.mod <- cv.IplBoost(times, status, design, lms=seq(0, 10, 0.1),
                      w=5, M=100, lambda=100,
                      folds=Kfold(length(times), 10))
# Fit the model using the tuned number of iterations
mod <- IplBoost(times, status, design, lms=seq(0, 10, 0.1),
                w=5, M=cv.mod$opt.m, lambda=100)
estimates <- mod$estimates[[cv.mod$opt.m + 1]]
}
